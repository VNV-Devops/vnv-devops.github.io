<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Topics on Vaisakh N V</title><link>https://vaisakhnv.com/topics/</link><description>Recent content in Topics on Vaisakh N V</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://vaisakhnv.com/topics/index.xml" rel="self" type="application/rss+xml"/><item><title>Formal verification</title><link>https://vaisakhnv.com/topics/formal-verification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vaisakhnv.com/topics/formal-verification/</guid><description>&lt;div class="ui-abstract" data-reveal&gt;
 &lt;div class="ui-abstract-kicker"&gt;Topic (verification)&lt;/div&gt;
 &lt;div class="ui-abstract-body"&gt;
 Formal verification is how I turn design intent into &lt;strong&gt;provable evidence&lt;/strong&gt;. My approach is pragmatic: focus on proof structure, build helper assertions, and iterate using counterexamples and coverage signals.
 &lt;/div&gt;
&lt;/div&gt;

&lt;div class="ui-metrics" data-reveal&gt;
 &lt;div class="ui-metrics-grid"&gt;
 &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Focus:&lt;/strong&gt; proof structure · convergence · evidence trail&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Methods:&lt;/strong&gt; helper lemmas · CEX-guided refinement · coverage-aware iteration&lt;/li&gt;
&lt;/ul&gt;

 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="what-i-optimize-for"&gt;What I optimize for&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Fast convergence:&lt;/strong&gt; break big goals into smaller provable claims&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Explainable failures:&lt;/strong&gt; counterexamples should point to actionable causes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Repeatability:&lt;/strong&gt; artifacts, logs, and assumptions are preserved so results can be reproduced&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="typical-workflow"&gt;Typical workflow&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Scope the intent:&lt;/strong&gt; what must be true (and under which assumptions)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Define the interface:&lt;/strong&gt; clocks/resets/handshakes; avoid underspecified properties&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Decompose:&lt;/strong&gt; create a staged plan (invariants / helper lemmas first)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Run and refine:&lt;/strong&gt; use counterexamples to repair constraints and properties&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Measure evidence:&lt;/strong&gt; coverage/vacuity checks; avoid “proved but meaningless”&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="where-this-shows-up-on-my-site"&gt;Where this shows up on my site&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Floating-point case study: proof decomposition + refinement&lt;/li&gt;
&lt;li&gt;Publications: canonical paper links and write-ups&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="ui-cta ui-card" data-reveal&gt;
 &lt;h2 class="ui-h2"&gt;Want to discuss a formal verification problem?&lt;/h2&gt;
 &lt;p class="ui-muted"&gt;If you want to collaborate, discuss roles, or review artifacts, reach out.&lt;/p&gt;</description></item><item><title>GenAI for EDA</title><link>https://vaisakhnv.com/topics/genai-for-eda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vaisakhnv.com/topics/genai-for-eda/</guid><description>&lt;div class="ui-abstract" data-reveal&gt;
 &lt;div class="ui-abstract-kicker"&gt;Topic (workflows)&lt;/div&gt;
 &lt;div class="ui-abstract-body"&gt;
 I use GenAI where it creates leverage: generating structured artifacts, accelerating iteration loops, and reducing repetitive engineering work—while keeping an evidence trail so results remain trustworthy.
 &lt;/div&gt;
&lt;/div&gt;

&lt;div class="ui-metrics" data-reveal&gt;
 &lt;div class="ui-metrics-grid"&gt;
 &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Goal:&lt;/strong&gt; faster iteration without losing rigor&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Approach:&lt;/strong&gt; tool-centric pipelines · structured artifacts · reproducibility&lt;/li&gt;
&lt;/ul&gt;

 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="what-i-believe-works-and-what-doesnt"&gt;What I believe works (and what doesn’t)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Works&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Constraining generation with &lt;strong&gt;structured schemas&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Grounding with &lt;strong&gt;project context&lt;/strong&gt; (specs, IRs, signal allowlists)&lt;/li&gt;
&lt;li&gt;Using LLMs for &lt;strong&gt;draft → critique → repair&lt;/strong&gt; loops with tooling in the loop&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Doesn’t&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>SystemVerilog and SVA</title><link>https://vaisakhnv.com/topics/systemverilog-sva/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://vaisakhnv.com/topics/systemverilog-sva/</guid><description>&lt;div class="ui-abstract" data-reveal&gt;
 &lt;div class="ui-abstract-kicker"&gt;Topic (properties)&lt;/div&gt;
 &lt;div class="ui-abstract-body"&gt;
 SVA is not just syntax—good assertions encode intent precisely, resist vacuity, and scale with a proof plan. I write SVA with explicit assumptions, clear temporal structure, and reusable patterns.
 &lt;/div&gt;
&lt;/div&gt;

&lt;div class="ui-metrics" data-reveal&gt;
 &lt;div class="ui-metrics-grid"&gt;
 &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Principles:&lt;/strong&gt; clarity · vacuity resistance · minimal assumptions&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Patterns:&lt;/strong&gt; interface contracts · invariants · refinement lemmas&lt;/li&gt;
&lt;/ul&gt;

 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="what-good-sva-means-in-practice"&gt;What “good SVA” means in practice&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Signal discipline:&lt;/strong&gt; assertions reference stable, meaningful signals (not accidental internals)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Temporal intent:&lt;/strong&gt; preconditions and consequences are separated clearly&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Assumptions are explicit:&lt;/strong&gt; environment constraints are documented and reviewable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vacuity checks:&lt;/strong&gt; proved properties should still be &lt;em&gt;informative&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="common-patterns-i-use"&gt;Common patterns I use&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Interface contracts:&lt;/strong&gt; request/ack, ready/valid, FIFO rules&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Safety properties:&lt;/strong&gt; “this bad thing never happens”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Liveness under assumptions:&lt;/strong&gt; “eventually” properties only where appropriate&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Helper lemmas:&lt;/strong&gt; small provable stepping stones for complex end-to-end goals&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="where-this-shows-up-on-my-site"&gt;Where this shows up on my site&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Formal case studies (proof structure)&lt;/li&gt;
&lt;li&gt;Publications (property strategy and evaluation)&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="ui-cta ui-card" data-reveal&gt;
 &lt;h2 class="ui-h2"&gt;Need help structuring assertions for a block?&lt;/h2&gt;
 &lt;p class="ui-muted"&gt;If you want to collaborate, discuss roles, or review artifacts, reach out.&lt;/p&gt;</description></item></channel></rss>